/*
Code automatically generated by asn1scc tool
*/
#include <limits.h>
#include <string.h>
#include <math.h>
#include "fault_injection_messages.h"

#if !defined(_MSC_VER) || _MSC_VER >= 1800
void MaskOperationASN_Initialize(MaskOperationASN* pVal)
{
    *pVal = (MaskOperationASN) setOperation;
}
#endif

 
flag MaskOperationASN_IsConstraintValid(const MaskOperationASN* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (((*pVal == setOperation) || (*pVal == xorOperation)) || (*pVal == orOperation));
	*pErrCode = ret ? 0 : ERR_MaskOperationASN;

	return ret;
}

flag MaskOperationASN_Encode(const MaskOperationASN* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? MaskOperationASN_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(*pVal) 
	    {
	        case setOperation:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 2);
	        	break;
	        case xorOperation:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 2);
	        	break;
	        case orOperation:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 2);
	        	break;
	        default:
	    	    *pErrCode = 1073741825; //COVERAGE_IGNORE
	    	    ret = FALSE;            //COVERAGE_IGNORE
	    }
    }

	return ret;
}

flag MaskOperationASN_Decode(MaskOperationASN* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint enumIndex;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 2);
	*pErrCode = ret ? 0 : 268435457;
	if (ret) {
	    switch(enumIndex) 
	    {
	        case 0: 
	            *pVal = setOperation;
	            break;
	        case 1: 
	            *pVal = xorOperation;
	            break;
	        case 2: 
	            *pVal = orOperation;
	            break;
	        default:
		        *pErrCode = 1073741826;     //COVERAGE_IGNORE
		        ret = FALSE;                //COVERAGE_IGNORE
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void ExchangeStatusEnumASN_Initialize(ExchangeStatusEnumASN* pVal)
{
    *pVal = (ExchangeStatusEnumASN) waitingConf;
}
#endif

 
flag ExchangeStatusEnumASN_IsConstraintValid(const ExchangeStatusEnumASN* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (((*pVal == waitingConf) || (*pVal == sendingActions)) || (*pVal == actionsReceived));
	*pErrCode = ret ? 0 : ERR_ExchangeStatusEnumASN;

	return ret;
}

flag ExchangeStatusEnumASN_Encode(const ExchangeStatusEnumASN* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? ExchangeStatusEnumASN_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(*pVal) 
	    {
	        case waitingConf:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 2);
	        	break;
	        case sendingActions:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 2);
	        	break;
	        case actionsReceived:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 2);
	        	break;
	        default:
	    	    *pErrCode = 1073741827; //COVERAGE_IGNORE
	    	    ret = FALSE;            //COVERAGE_IGNORE
	    }
    }

	return ret;
}

flag ExchangeStatusEnumASN_Decode(ExchangeStatusEnumASN* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint enumIndex;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 2);
	*pErrCode = ret ? 0 : 268435458;
	if (ret) {
	    switch(enumIndex) 
	    {
	        case 0: 
	            *pVal = waitingConf;
	            break;
	        case 1: 
	            *pVal = sendingActions;
	            break;
	        case 2: 
	            *pVal = actionsReceived;
	            break;
	        default:
		        *pErrCode = 1073741828;     //COVERAGE_IGNORE
		        ret = FALSE;                //COVERAGE_IGNORE
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void ExchangeStatusASN_Initialize(ExchangeStatusASN* pVal)
{
    *pVal = (ExchangeStatusASN) {
    .status = waitingConf
};
}
#endif

 
flag ExchangeStatusASN_IsConstraintValid(const ExchangeStatusASN* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = ExchangeStatusEnumASN_IsConstraintValid(&pVal->status, pErrCode);


	return ret;
}

flag ExchangeStatusASN_Encode(const ExchangeStatusASN* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? ExchangeStatusASN_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode status */
	    ret = ExchangeStatusEnumASN_Encode(&pVal->status, pBitStrm, pErrCode, FALSE);

    }

	return ret;
}

flag ExchangeStatusASN_Decode(ExchangeStatusASN* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode status */
	ret = ExchangeStatusEnumASN_Decode(&pVal->status, pBitStrm, pErrCode);
	


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void LogMsgASN_Initialize(LogMsgASN* pVal)
{
    *pVal = (LogMsgASN) {

};
}
#endif

 
flag LogMsgASN_IsConstraintValid(const LogMsgASN* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;


	return ret;
}

flag LogMsgASN_Encode(const LogMsgASN* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? LogMsgASN_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
    }

	return ret;
}

flag LogMsgASN_Decode(LogMsgASN* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void LogASN_logIndex_Initialize(LogASN_logIndex* pVal)
{
    *pVal = (LogASN_logIndex) 0;
}
#endif

 
flag LogASN_logIndex_IsConstraintValid(const LogASN_logIndex* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (*pVal <= 4294967295LL);
	*pErrCode = ret ? 0 : ERR_LogASN_logIndex;

	return ret;
}

flag LogASN_logIndex_Encode(const LogASN_logIndex* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? LogASN_logIndex_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, *pVal, 0, 4294967295LL);
    }

	return ret;
}

flag LogASN_logIndex_Decode(LogASN_logIndex* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 4294967295LL);
	*pErrCode = ret ? 0 : 268435459;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void LogASN_logDescription_Initialize(LogASN_logDescription* pVal)
{
    *pVal = (LogASN_logDescription) {
    {
        0x00
    }
};
}
#endif

 
flag LogASN_logDescription_IsConstraintValid(const LogASN_logDescription* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (128 == 128);
	*pErrCode = ret ? 0 : ERR_LogASN_logDescription;

	return ret;
}

flag LogASN_logDescription_Encode(const LogASN_logDescription* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? LogASN_logDescription_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    	
	    for(i1=0; (i1 < (int)128) && ret; i1++) 
	    {
	    	BitStream_AppendByte0(pBitStrm, pVal->arr[i1]);
	    }
    }

	return ret;
}

flag LogASN_logDescription_Decode(LogASN_logDescription* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1=0;

		
	for(i1=0; (i1 < (int)128) && ret; i1++) 
	{
		ret = BitStream_ReadByte(pBitStrm, &pVal->arr[i1]); 
		*pErrCode = ret ? 0 : 268435460;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void LogStringValueASN_stringValue_Initialize(LogStringValueASN_stringValue* pVal)
{
    *pVal = (LogStringValueASN_stringValue) {
    {
        0x00
    }
};
}
#endif

 
flag LogStringValueASN_stringValue_IsConstraintValid(const LogStringValueASN_stringValue* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (128 == 128);
	*pErrCode = ret ? 0 : ERR_LogStringValueASN_stringValue;

	return ret;
}

flag LogStringValueASN_stringValue_Encode(const LogStringValueASN_stringValue* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? LogStringValueASN_stringValue_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    	
	    for(i1=0; (i1 < (int)128) && ret; i1++) 
	    {
	    	BitStream_AppendByte0(pBitStrm, pVal->arr[i1]);
	    }
    }

	return ret;
}

flag LogStringValueASN_stringValue_Decode(LogStringValueASN_stringValue* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1=0;

		
	for(i1=0; (i1 < (int)128) && ret; i1++) 
	{
		ret = BitStream_ReadByte(pBitStrm, &pVal->arr[i1]); 
		*pErrCode = ret ? 0 : 268435461;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void LogStringValueASN_Initialize(LogStringValueASN* pVal)
{
    *pVal = (LogStringValueASN) {
    .stringValue = {
        {
            0x00
        }
    }
};
}
#endif

 
flag LogStringValueASN_IsConstraintValid(const LogStringValueASN* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = LogStringValueASN_stringValue_IsConstraintValid(&pVal->stringValue, pErrCode);


	return ret;
}

flag LogStringValueASN_Encode(const LogStringValueASN* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? LogStringValueASN_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode stringValue */
	    ret = LogStringValueASN_stringValue_Encode(&pVal->stringValue, pBitStrm, pErrCode, FALSE);

    }

	return ret;
}

flag LogStringValueASN_Decode(LogStringValueASN* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode stringValue */
	ret = LogStringValueASN_stringValue_Decode(&pVal->stringValue, pBitStrm, pErrCode);
	


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void LogIntValueASN_intValue_Initialize(LogIntValueASN_intValue* pVal)
{
    *pVal = (LogIntValueASN_intValue) 0;
}
#endif

 
flag LogIntValueASN_intValue_IsConstraintValid(const LogIntValueASN_intValue* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (*pVal <= 4294967295LL);
	*pErrCode = ret ? 0 : ERR_LogIntValueASN_intValue;

	return ret;
}

flag LogIntValueASN_intValue_Encode(const LogIntValueASN_intValue* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? LogIntValueASN_intValue_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, *pVal, 0, 4294967295LL);
    }

	return ret;
}

flag LogIntValueASN_intValue_Decode(LogIntValueASN_intValue* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 4294967295LL);
	*pErrCode = ret ? 0 : 268435462;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void LogIntValueASN_Initialize(LogIntValueASN* pVal)
{
    *pVal = (LogIntValueASN) {
    .intValue = 0
};
}
#endif

 
flag LogIntValueASN_IsConstraintValid(const LogIntValueASN* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = LogIntValueASN_intValue_IsConstraintValid(&pVal->intValue, pErrCode);


	return ret;
}

flag LogIntValueASN_Encode(const LogIntValueASN* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? LogIntValueASN_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode intValue */
	    ret = LogIntValueASN_intValue_Encode(&pVal->intValue, pBitStrm, pErrCode, FALSE);

    }

	return ret;
}

flag LogIntValueASN_Decode(LogIntValueASN* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode intValue */
	ret = LogIntValueASN_intValue_Decode(&pVal->intValue, pBitStrm, pErrCode);
	


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void LogChoiceASN_Initialize(LogChoiceASN* pVal)
{
    *pVal = (LogChoiceASN) {
    .kind = logMsg_PRESENT,
    .u = { .logMsg = {

}}
};
}
#endif

 
flag LogChoiceASN_IsConstraintValid(const LogChoiceASN* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	switch (pVal->kind) {
	    case logMsg_PRESENT :
	        ret = LogMsgASN_IsConstraintValid(&pVal->u.logMsg, pErrCode);
	        break;
	    case logIntValue_PRESENT :
	        ret = LogIntValueASN_IsConstraintValid(&pVal->u.logIntValue, pErrCode);
	        break;
	    case logStringValue_PRESENT :
	        ret = LogStringValueASN_IsConstraintValid(&pVal->u.logStringValue, pErrCode);
	        break;
	    default:
		    *pErrCode = 805306369;   //COVERAGE_IGNORE
		    ret = FALSE;                    //COVERAGE_IGNORE
	}

	return ret;
}

flag LogChoiceASN_Encode(const LogChoiceASN* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? LogChoiceASN_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(pVal->kind) 
	    {
	    case logMsg_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 2);
	    	ret = LogMsgASN_Encode(&pVal->u.logMsg, pBitStrm, pErrCode, FALSE);
	    	break;
	    case logIntValue_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 2);
	    	ret = LogIntValueASN_Encode(&pVal->u.logIntValue, pBitStrm, pErrCode, FALSE);
	    	break;
	    case logStringValue_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 2);
	    	ret = LogStringValueASN_Encode(&pVal->u.logStringValue, pBitStrm, pErrCode, FALSE);
	    	break;
	    default:
	        *pErrCode = 805306370;         //COVERAGE_IGNORE
	        ret = FALSE;                    //COVERAGE_IGNORE
	    }
    }

	return ret;
}

flag LogChoiceASN_Decode(LogChoiceASN* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nChoiceIndex;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nChoiceIndex, 0, 2);
	*pErrCode = ret ? 0 : 268435463;
	if (ret) {
	    switch(nChoiceIndex) 
	    {
	    case 0:
	    	pVal->kind = logMsg_PRESENT;
	    	ret = LogMsgASN_Decode(&pVal->u.logMsg, pBitStrm, pErrCode);
	    	break;
	    case 1:
	    	pVal->kind = logIntValue_PRESENT;
	    	ret = LogIntValueASN_Decode(&pVal->u.logIntValue, pBitStrm, pErrCode);
	    	break;
	    case 2:
	    	pVal->kind = logStringValue_PRESENT;
	    	ret = LogStringValueASN_Decode(&pVal->u.logStringValue, pBitStrm, pErrCode);
	    	break;
	    default:
	        *pErrCode = 805306371;     //COVERAGE_IGNORE
	        ret = FALSE;                //COVERAGE_IGNORE
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void LogASN_Initialize(LogASN* pVal)
{
    *pVal = (LogASN) {
    .logDescription = {
        {
            0x00
        }
    },
    .logChoice = {
        .kind = logMsg_PRESENT,
        .u = { .logMsg = {

    }}
    },
    .logIndex = 0
};
}
#endif

 
flag LogASN_IsConstraintValid(const LogASN* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = LogASN_logDescription_IsConstraintValid(&pVal->logDescription, pErrCode);
	if (ret) {
	    ret = LogChoiceASN_IsConstraintValid(&pVal->logChoice, pErrCode);
	    if (ret) {
	        ret = LogASN_logIndex_IsConstraintValid(&pVal->logIndex, pErrCode);
	    
	    }
	}

	return ret;
}

flag LogASN_Encode(const LogASN* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? LogASN_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode logDescription */
	    ret = LogASN_logDescription_Encode(&pVal->logDescription, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode logChoice */
	        ret = LogChoiceASN_Encode(&pVal->logChoice, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode logIndex */
	            ret = LogASN_logIndex_Encode(&pVal->logIndex, pBitStrm, pErrCode, FALSE);
	        
	        }
	    }
    }

	return ret;
}

flag LogASN_Decode(LogASN* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode logDescription */
	ret = LogASN_logDescription_Decode(&pVal->logDescription, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode logChoice */
	    ret = LogChoiceASN_Decode(&pVal->logChoice, pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode logIndex */
	        ret = LogASN_logIndex_Decode(&pVal->logIndex, pBitStrm, pErrCode);
	    
	    }
	}


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void InjectionConfigurationASN_memoryInjectionActionsNum_Initialize(InjectionConfigurationASN_memoryInjectionActionsNum* pVal)
{
    *pVal = (InjectionConfigurationASN_memoryInjectionActionsNum) 0;
}
#endif

 
flag InjectionConfigurationASN_memoryInjectionActionsNum_IsConstraintValid(const InjectionConfigurationASN_memoryInjectionActionsNum* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (*pVal <= 4294967295LL);
	*pErrCode = ret ? 0 : ERR_InjectionConfigurationASN_memoryInjectionActionsNum;

	return ret;
}

flag InjectionConfigurationASN_memoryInjectionActionsNum_Encode(const InjectionConfigurationASN_memoryInjectionActionsNum* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? InjectionConfigurationASN_memoryInjectionActionsNum_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, *pVal, 0, 4294967295LL);
    }

	return ret;
}

flag InjectionConfigurationASN_memoryInjectionActionsNum_Decode(InjectionConfigurationASN_memoryInjectionActionsNum* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 4294967295LL);
	*pErrCode = ret ? 0 : 268435464;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void InjectionConfigurationASN_registerInjectionActionsNum_Initialize(InjectionConfigurationASN_registerInjectionActionsNum* pVal)
{
    *pVal = (InjectionConfigurationASN_registerInjectionActionsNum) 0;
}
#endif

 
flag InjectionConfigurationASN_registerInjectionActionsNum_IsConstraintValid(const InjectionConfigurationASN_registerInjectionActionsNum* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (*pVal <= 4294967295LL);
	*pErrCode = ret ? 0 : ERR_InjectionConfigurationASN_registerInjectionActionsNum;

	return ret;
}

flag InjectionConfigurationASN_registerInjectionActionsNum_Encode(const InjectionConfigurationASN_registerInjectionActionsNum* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? InjectionConfigurationASN_registerInjectionActionsNum_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, *pVal, 0, 4294967295LL);
    }

	return ret;
}

flag InjectionConfigurationASN_registerInjectionActionsNum_Decode(InjectionConfigurationASN_registerInjectionActionsNum* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 4294967295LL);
	*pErrCode = ret ? 0 : 268435465;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void InjectionConfigurationASN_injectionActionsNum_Initialize(InjectionConfigurationASN_injectionActionsNum* pVal)
{
    *pVal = (InjectionConfigurationASN_injectionActionsNum) 0;
}
#endif

 
flag InjectionConfigurationASN_injectionActionsNum_IsConstraintValid(const InjectionConfigurationASN_injectionActionsNum* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (*pVal <= 4294967295LL);
	*pErrCode = ret ? 0 : ERR_InjectionConfigurationASN_injectionActionsNum;

	return ret;
}

flag InjectionConfigurationASN_injectionActionsNum_Encode(const InjectionConfigurationASN_injectionActionsNum* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? InjectionConfigurationASN_injectionActionsNum_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, *pVal, 0, 4294967295LL);
    }

	return ret;
}

flag InjectionConfigurationASN_injectionActionsNum_Decode(InjectionConfigurationASN_injectionActionsNum* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 4294967295LL);
	*pErrCode = ret ? 0 : 268435466;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void InjectionConfigurationASN_Initialize(InjectionConfigurationASN* pVal)
{
    *pVal = (InjectionConfigurationASN) {
    .logging = FALSE,
    .injectionActionsNum = 0,
    .registerInjectionActionsNum = 0,
    .memoryInjectionActionsNum = 0
};
}
#endif

 
flag InjectionConfigurationASN_IsConstraintValid(const InjectionConfigurationASN* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = TRUE; *pErrCode = 0;
	if (ret) {
	    ret = InjectionConfigurationASN_injectionActionsNum_IsConstraintValid(&pVal->injectionActionsNum, pErrCode);
	    if (ret) {
	        ret = InjectionConfigurationASN_registerInjectionActionsNum_IsConstraintValid(&pVal->registerInjectionActionsNum, pErrCode);
	        if (ret) {
	            ret = InjectionConfigurationASN_memoryInjectionActionsNum_IsConstraintValid(&pVal->memoryInjectionActionsNum, pErrCode);
	        
	        }
	    }
	}

	return ret;
}

flag InjectionConfigurationASN_Encode(const InjectionConfigurationASN* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? InjectionConfigurationASN_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode logging */
	    BitStream_AppendBit(pBitStrm,pVal->logging);
	    if (ret) {
	        /*Encode injectionActionsNum */
	        ret = InjectionConfigurationASN_injectionActionsNum_Encode(&pVal->injectionActionsNum, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode registerInjectionActionsNum */
	            ret = InjectionConfigurationASN_registerInjectionActionsNum_Encode(&pVal->registerInjectionActionsNum, pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode memoryInjectionActionsNum */
	                ret = InjectionConfigurationASN_memoryInjectionActionsNum_Encode(&pVal->memoryInjectionActionsNum, pBitStrm, pErrCode, FALSE);
	            
	            }
	        }
	    }
    }

	return ret;
}

flag InjectionConfigurationASN_Decode(InjectionConfigurationASN* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode logging */
	ret = BitStream_ReadBit(pBitStrm, &pVal->logging);
	*pErrCode = ret ? 0 : 268435467;
	if (ret) {
	    /*Decode injectionActionsNum */
	    ret = InjectionConfigurationASN_injectionActionsNum_Decode(&pVal->injectionActionsNum, pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode registerInjectionActionsNum */
	        ret = InjectionConfigurationASN_registerInjectionActionsNum_Decode(&pVal->registerInjectionActionsNum, pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode memoryInjectionActionsNum */
	            ret = InjectionConfigurationASN_memoryInjectionActionsNum_Decode(&pVal->memoryInjectionActionsNum, pBitStrm, pErrCode);
	        
	        }
	    }
	}


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void InjectionActionASN_injectionActionIndex_Initialize(InjectionActionASN_injectionActionIndex* pVal)
{
    *pVal = (InjectionActionASN_injectionActionIndex) 0;
}
#endif

 
flag InjectionActionASN_injectionActionIndex_IsConstraintValid(const InjectionActionASN_injectionActionIndex* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (*pVal <= 4294967295LL);
	*pErrCode = ret ? 0 : ERR_InjectionActionASN_injectionActionIndex;

	return ret;
}

flag InjectionActionASN_injectionActionIndex_Encode(const InjectionActionASN_injectionActionIndex* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? InjectionActionASN_injectionActionIndex_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, *pVal, 0, 4294967295LL);
    }

	return ret;
}

flag InjectionActionASN_injectionActionIndex_Decode(InjectionActionASN_injectionActionIndex* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 4294967295LL);
	*pErrCode = ret ? 0 : 268435468;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void MemoryInjectionActionASN_omitCallsNumber_Initialize(MemoryInjectionActionASN_omitCallsNumber* pVal)
{
    *pVal = (MemoryInjectionActionASN_omitCallsNumber) 0;
}
#endif

 
flag MemoryInjectionActionASN_omitCallsNumber_IsConstraintValid(const MemoryInjectionActionASN_omitCallsNumber* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (*pVal <= 4294967295LL);
	*pErrCode = ret ? 0 : ERR_MemoryInjectionActionASN_omitCallsNumber;

	return ret;
}

flag MemoryInjectionActionASN_omitCallsNumber_Encode(const MemoryInjectionActionASN_omitCallsNumber* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? MemoryInjectionActionASN_omitCallsNumber_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, *pVal, 0, 4294967295LL);
    }

	return ret;
}

flag MemoryInjectionActionASN_omitCallsNumber_Decode(MemoryInjectionActionASN_omitCallsNumber* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 4294967295LL);
	*pErrCode = ret ? 0 : 268435469;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void MemoryInjectionActionASN_valueMask_Initialize(MemoryInjectionActionASN_valueMask* pVal)
{
    *pVal = (MemoryInjectionActionASN_valueMask) 0;
}
#endif

 
flag MemoryInjectionActionASN_valueMask_IsConstraintValid(const MemoryInjectionActionASN_valueMask* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (*pVal <= 4294967295LL);
	*pErrCode = ret ? 0 : ERR_MemoryInjectionActionASN_valueMask;

	return ret;
}

flag MemoryInjectionActionASN_valueMask_Encode(const MemoryInjectionActionASN_valueMask* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? MemoryInjectionActionASN_valueMask_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, *pVal, 0, 4294967295LL);
    }

	return ret;
}

flag MemoryInjectionActionASN_valueMask_Decode(MemoryInjectionActionASN_valueMask* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 4294967295LL);
	*pErrCode = ret ? 0 : 268435470;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void MemoryInjectionActionASN_memoryAddress_Initialize(MemoryInjectionActionASN_memoryAddress* pVal)
{
    *pVal = (MemoryInjectionActionASN_memoryAddress) 0;
}
#endif

 
flag MemoryInjectionActionASN_memoryAddress_IsConstraintValid(const MemoryInjectionActionASN_memoryAddress* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (*pVal <= 4294967295LL);
	*pErrCode = ret ? 0 : ERR_MemoryInjectionActionASN_memoryAddress;

	return ret;
}

flag MemoryInjectionActionASN_memoryAddress_Encode(const MemoryInjectionActionASN_memoryAddress* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? MemoryInjectionActionASN_memoryAddress_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, *pVal, 0, 4294967295LL);
    }

	return ret;
}

flag MemoryInjectionActionASN_memoryAddress_Decode(MemoryInjectionActionASN_memoryAddress* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 4294967295LL);
	*pErrCode = ret ? 0 : 268435471;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void MemoryInjectionActionASN_injectionAddress_Initialize(MemoryInjectionActionASN_injectionAddress* pVal)
{
    *pVal = (MemoryInjectionActionASN_injectionAddress) 0;
}
#endif

 
flag MemoryInjectionActionASN_injectionAddress_IsConstraintValid(const MemoryInjectionActionASN_injectionAddress* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (*pVal <= 4294967295LL);
	*pErrCode = ret ? 0 : ERR_MemoryInjectionActionASN_injectionAddress;

	return ret;
}

flag MemoryInjectionActionASN_injectionAddress_Encode(const MemoryInjectionActionASN_injectionAddress* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? MemoryInjectionActionASN_injectionAddress_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, *pVal, 0, 4294967295LL);
    }

	return ret;
}

flag MemoryInjectionActionASN_injectionAddress_Decode(MemoryInjectionActionASN_injectionAddress* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 4294967295LL);
	*pErrCode = ret ? 0 : 268435472;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void MemoryInjectionActionASN_Initialize(MemoryInjectionActionASN* pVal)
{
    *pVal = (MemoryInjectionActionASN) {
    .injectionAddress = 0,
    .memoryAddress = 0,
    .valueMask = 0,
    .omitCallsNumber = 0,
    .maskOperation = setOperation
};
}
#endif

 
flag MemoryInjectionActionASN_IsConstraintValid(const MemoryInjectionActionASN* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = MemoryInjectionActionASN_injectionAddress_IsConstraintValid(&pVal->injectionAddress, pErrCode);
	if (ret) {
	    ret = MemoryInjectionActionASN_memoryAddress_IsConstraintValid(&pVal->memoryAddress, pErrCode);
	    if (ret) {
	        ret = MemoryInjectionActionASN_valueMask_IsConstraintValid(&pVal->valueMask, pErrCode);
	        if (ret) {
	            ret = MemoryInjectionActionASN_omitCallsNumber_IsConstraintValid(&pVal->omitCallsNumber, pErrCode);
	            if (ret) {
	                ret = MaskOperationASN_IsConstraintValid(&pVal->maskOperation, pErrCode);
	            
	            }
	        }
	    }
	}

	return ret;
}

flag MemoryInjectionActionASN_Encode(const MemoryInjectionActionASN* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? MemoryInjectionActionASN_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode injectionAddress */
	    ret = MemoryInjectionActionASN_injectionAddress_Encode(&pVal->injectionAddress, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode memoryAddress */
	        ret = MemoryInjectionActionASN_memoryAddress_Encode(&pVal->memoryAddress, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode valueMask */
	            ret = MemoryInjectionActionASN_valueMask_Encode(&pVal->valueMask, pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode omitCallsNumber */
	                ret = MemoryInjectionActionASN_omitCallsNumber_Encode(&pVal->omitCallsNumber, pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode maskOperation */
	                    ret = MaskOperationASN_Encode(&pVal->maskOperation, pBitStrm, pErrCode, FALSE);
	                
	                }
	            }
	        }
	    }
    }

	return ret;
}

flag MemoryInjectionActionASN_Decode(MemoryInjectionActionASN* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode injectionAddress */
	ret = MemoryInjectionActionASN_injectionAddress_Decode(&pVal->injectionAddress, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode memoryAddress */
	    ret = MemoryInjectionActionASN_memoryAddress_Decode(&pVal->memoryAddress, pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode valueMask */
	        ret = MemoryInjectionActionASN_valueMask_Decode(&pVal->valueMask, pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode omitCallsNumber */
	            ret = MemoryInjectionActionASN_omitCallsNumber_Decode(&pVal->omitCallsNumber, pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode maskOperation */
	                ret = MaskOperationASN_Decode(&pVal->maskOperation, pBitStrm, pErrCode);
	            
	            }
	        }
	    }
	}


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void RegisterInjectionActionASN_omitCallsNumber_Initialize(RegisterInjectionActionASN_omitCallsNumber* pVal)
{
    *pVal = (RegisterInjectionActionASN_omitCallsNumber) 0;
}
#endif

 
flag RegisterInjectionActionASN_omitCallsNumber_IsConstraintValid(const RegisterInjectionActionASN_omitCallsNumber* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (*pVal <= 4294967295LL);
	*pErrCode = ret ? 0 : ERR_RegisterInjectionActionASN_omitCallsNumber;

	return ret;
}

flag RegisterInjectionActionASN_omitCallsNumber_Encode(const RegisterInjectionActionASN_omitCallsNumber* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? RegisterInjectionActionASN_omitCallsNumber_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, *pVal, 0, 4294967295LL);
    }

	return ret;
}

flag RegisterInjectionActionASN_omitCallsNumber_Decode(RegisterInjectionActionASN_omitCallsNumber* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 4294967295LL);
	*pErrCode = ret ? 0 : 268435473;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void RegisterInjectionActionASN_valueMask_Initialize(RegisterInjectionActionASN_valueMask* pVal)
{
    *pVal = (RegisterInjectionActionASN_valueMask) 0;
}
#endif

 
flag RegisterInjectionActionASN_valueMask_IsConstraintValid(const RegisterInjectionActionASN_valueMask* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (*pVal <= 4294967295LL);
	*pErrCode = ret ? 0 : ERR_RegisterInjectionActionASN_valueMask;

	return ret;
}

flag RegisterInjectionActionASN_valueMask_Encode(const RegisterInjectionActionASN_valueMask* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? RegisterInjectionActionASN_valueMask_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, *pVal, 0, 4294967295LL);
    }

	return ret;
}

flag RegisterInjectionActionASN_valueMask_Decode(RegisterInjectionActionASN_valueMask* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 4294967295LL);
	*pErrCode = ret ? 0 : 268435474;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void RegisterInjectionActionASN_registerIndex_Initialize(RegisterInjectionActionASN_registerIndex* pVal)
{
    *pVal = (RegisterInjectionActionASN_registerIndex) 0;
}
#endif

 
flag RegisterInjectionActionASN_registerIndex_IsConstraintValid(const RegisterInjectionActionASN_registerIndex* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (*pVal <= 15);
	*pErrCode = ret ? 0 : ERR_RegisterInjectionActionASN_registerIndex;

	return ret;
}

flag RegisterInjectionActionASN_registerIndex_Encode(const RegisterInjectionActionASN_registerIndex* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? RegisterInjectionActionASN_registerIndex_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, *pVal, 0, 15);
    }

	return ret;
}

flag RegisterInjectionActionASN_registerIndex_Decode(RegisterInjectionActionASN_registerIndex* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 15);
	*pErrCode = ret ? 0 : 268435475;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void RegisterInjectionActionASN_injectionAddress_Initialize(RegisterInjectionActionASN_injectionAddress* pVal)
{
    *pVal = (RegisterInjectionActionASN_injectionAddress) 0;
}
#endif

 
flag RegisterInjectionActionASN_injectionAddress_IsConstraintValid(const RegisterInjectionActionASN_injectionAddress* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (*pVal <= 4294967295LL);
	*pErrCode = ret ? 0 : ERR_RegisterInjectionActionASN_injectionAddress;

	return ret;
}

flag RegisterInjectionActionASN_injectionAddress_Encode(const RegisterInjectionActionASN_injectionAddress* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? RegisterInjectionActionASN_injectionAddress_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, *pVal, 0, 4294967295LL);
    }

	return ret;
}

flag RegisterInjectionActionASN_injectionAddress_Decode(RegisterInjectionActionASN_injectionAddress* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 4294967295LL);
	*pErrCode = ret ? 0 : 268435476;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void RegisterInjectionActionASN_Initialize(RegisterInjectionActionASN* pVal)
{
    *pVal = (RegisterInjectionActionASN) {
    .injectionAddress = 0,
    .registerIndex = 0,
    .valueMask = 0,
    .omitCallsNumber = 0,
    .maskOperation = setOperation
};
}
#endif

 
flag RegisterInjectionActionASN_IsConstraintValid(const RegisterInjectionActionASN* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = RegisterInjectionActionASN_injectionAddress_IsConstraintValid(&pVal->injectionAddress, pErrCode);
	if (ret) {
	    ret = RegisterInjectionActionASN_registerIndex_IsConstraintValid(&pVal->registerIndex, pErrCode);
	    if (ret) {
	        ret = RegisterInjectionActionASN_valueMask_IsConstraintValid(&pVal->valueMask, pErrCode);
	        if (ret) {
	            ret = RegisterInjectionActionASN_omitCallsNumber_IsConstraintValid(&pVal->omitCallsNumber, pErrCode);
	            if (ret) {
	                ret = MaskOperationASN_IsConstraintValid(&pVal->maskOperation, pErrCode);
	            
	            }
	        }
	    }
	}

	return ret;
}

flag RegisterInjectionActionASN_Encode(const RegisterInjectionActionASN* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? RegisterInjectionActionASN_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode injectionAddress */
	    ret = RegisterInjectionActionASN_injectionAddress_Encode(&pVal->injectionAddress, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode registerIndex */
	        ret = RegisterInjectionActionASN_registerIndex_Encode(&pVal->registerIndex, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode valueMask */
	            ret = RegisterInjectionActionASN_valueMask_Encode(&pVal->valueMask, pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode omitCallsNumber */
	                ret = RegisterInjectionActionASN_omitCallsNumber_Encode(&pVal->omitCallsNumber, pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode maskOperation */
	                    ret = MaskOperationASN_Encode(&pVal->maskOperation, pBitStrm, pErrCode, FALSE);
	                
	                }
	            }
	        }
	    }
    }

	return ret;
}

flag RegisterInjectionActionASN_Decode(RegisterInjectionActionASN* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode injectionAddress */
	ret = RegisterInjectionActionASN_injectionAddress_Decode(&pVal->injectionAddress, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode registerIndex */
	    ret = RegisterInjectionActionASN_registerIndex_Decode(&pVal->registerIndex, pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode valueMask */
	        ret = RegisterInjectionActionASN_valueMask_Decode(&pVal->valueMask, pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode omitCallsNumber */
	            ret = RegisterInjectionActionASN_omitCallsNumber_Decode(&pVal->omitCallsNumber, pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode maskOperation */
	                ret = MaskOperationASN_Decode(&pVal->maskOperation, pBitStrm, pErrCode);
	            
	            }
	        }
	    }
	}


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void InjectionActionChoiceASN_Initialize(InjectionActionChoiceASN* pVal)
{
    *pVal = (InjectionActionChoiceASN) {
    .kind = registerAction_PRESENT,
    .u = { .registerAction = {
    .injectionAddress = 0,
    .registerIndex = 0,
    .valueMask = 0,
    .omitCallsNumber = 0,
    .maskOperation = setOperation
}}
};
}
#endif

 
flag InjectionActionChoiceASN_IsConstraintValid(const InjectionActionChoiceASN* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	switch (pVal->kind) {
	    case registerAction_PRESENT :
	        ret = RegisterInjectionActionASN_IsConstraintValid(&pVal->u.registerAction, pErrCode);
	        break;
	    case memoryAction_PRESENT :
	        ret = MemoryInjectionActionASN_IsConstraintValid(&pVal->u.memoryAction, pErrCode);
	        break;
	    default:
		    *pErrCode = 805306372;   //COVERAGE_IGNORE
		    ret = FALSE;                    //COVERAGE_IGNORE
	}

	return ret;
}

flag InjectionActionChoiceASN_Encode(const InjectionActionChoiceASN* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? InjectionActionChoiceASN_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(pVal->kind) 
	    {
	    case registerAction_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	    	ret = RegisterInjectionActionASN_Encode(&pVal->u.registerAction, pBitStrm, pErrCode, FALSE);
	    	break;
	    case memoryAction_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	    	ret = MemoryInjectionActionASN_Encode(&pVal->u.memoryAction, pBitStrm, pErrCode, FALSE);
	    	break;
	    default:
	        *pErrCode = 805306373;         //COVERAGE_IGNORE
	        ret = FALSE;                    //COVERAGE_IGNORE
	    }
    }

	return ret;
}

flag InjectionActionChoiceASN_Decode(InjectionActionChoiceASN* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nChoiceIndex;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nChoiceIndex, 0, 1);
	*pErrCode = ret ? 0 : 268435477;
	if (ret) {
	    switch(nChoiceIndex) 
	    {
	    case 0:
	    	pVal->kind = registerAction_PRESENT;
	    	ret = RegisterInjectionActionASN_Decode(&pVal->u.registerAction, pBitStrm, pErrCode);
	    	break;
	    case 1:
	    	pVal->kind = memoryAction_PRESENT;
	    	ret = MemoryInjectionActionASN_Decode(&pVal->u.memoryAction, pBitStrm, pErrCode);
	    	break;
	    default:
	        *pErrCode = 805306374;     //COVERAGE_IGNORE
	        ret = FALSE;                //COVERAGE_IGNORE
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void InjectionActionASN_Initialize(InjectionActionASN* pVal)
{
    *pVal = (InjectionActionASN) {
    .injectionAction = {
        .kind = registerAction_PRESENT,
        .u = { .registerAction = {
        .injectionAddress = 0,
        .registerIndex = 0,
        .valueMask = 0,
        .omitCallsNumber = 0,
        .maskOperation = setOperation
    }}
    },
    .injectionActionIndex = 0
};
}
#endif

 
flag InjectionActionASN_IsConstraintValid(const InjectionActionASN* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = InjectionActionChoiceASN_IsConstraintValid(&pVal->injectionAction, pErrCode);
	if (ret) {
	    ret = InjectionActionASN_injectionActionIndex_IsConstraintValid(&pVal->injectionActionIndex, pErrCode);
	
	}

	return ret;
}

flag InjectionActionASN_Encode(const InjectionActionASN* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? InjectionActionASN_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode injectionAction */
	    ret = InjectionActionChoiceASN_Encode(&pVal->injectionAction, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode injectionActionIndex */
	        ret = InjectionActionASN_injectionActionIndex_Encode(&pVal->injectionActionIndex, pBitStrm, pErrCode, FALSE);
	    
	    }
    }

	return ret;
}

flag InjectionActionASN_Decode(InjectionActionASN* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode injectionAction */
	ret = InjectionActionChoiceASN_Decode(&pVal->injectionAction, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode injectionActionIndex */
	    ret = InjectionActionASN_injectionActionIndex_Decode(&pVal->injectionActionIndex, pBitStrm, pErrCode);
	
	}


	return ret;
}

